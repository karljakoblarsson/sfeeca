\documentclass{scrartcl}

\usepackage[utf8]{inputenc}

\usepackage{natbib}
\usepackage{hyperref}
\usepackage{csquotes}
\usepackage{listings}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
% \usepackage{parskip}
% \setlength{\parskip}{10pt}
\usepackage{tikz}
\usetikzlibrary{arrows, decorations.markings}
\usepackage{chngcntr}
\counterwithout{figure}{section}


\begin{document}

\begin{titlepage}

\centering
{\scshape\LARGE Master thesis project proposal}

\vspace{0.5cm}
{\huge\bfseries A Functional Implementation of Finite Element Exterior Calculus}

\vspace{2cm}
{\Large Jakob Larsson \texttt{<jakob@karljakoblarsson.com>}}

\vspace{1.0cm}
{\large Suggested Supervisor at CSE: Patrik Jansson }

% \vspace{1.5cm}
\vspace{1.5cm}
{\large Relevant completed courses:}

{\itshape
Types for Programs and Proofs, DAT350 \\
Advanced Functional programming, TDA342 \\
}

\vfill
{\large \today}

\end{titlepage}


% Draft 5 New after meeting with Suprevisor
%
%

% \section{Introduction}

Writing correct software is hard.  Functional programming proposes several
techniques to make it easier.  One technique is to embed domain specific
objects and terms in the programming language, to make a so called Domain
Specific Language, or DSL.~\cite{van2000domain}

% In this thesis we wish to
% investigate how a DSL for mathematics can improve an existing software project.

When implementing mathematical software, there can be two classes of bugs, both
"normal" bugs and mathematical errors. Functional programming offer several
tools to deal with the first kind. The second kind however, is harder to
combat. It is often hard to differentiate between the correct set of numbers
and the wrong in the answer. Our thesis is that we can model the actual algebra
and mathematical theory as a Haskell DSL with types and typeclasses. This
could allow the compiler to catch mathematical errors.


This thesis is intended as a case study for implementing a mathematical theory
as a Haskell DSL. The theory chosen is Finite Element Exterior Calculus
(FEEC)~\cite{arnold2006finite}. FEEC is a useful tool when solving Partial
Differential Equations.  There exists a prototype functional implementation of
FEEC written in Haskell called
FEECa~\footnote{https://github.com/Airini/FEECa}. However, the FEECa
implementation is bound to the `double` type and is not polymorphic. We wish to
keep the implementation fully polymorphic in the underlying number type which
for example would allow for exact testing with rational numbers.



% \section{Goals and Challenges}

The goal is to show how a mathematical theory can be implemented as a Haskell
DSL and research the benefits. A first step is to use automated testing, with
QuickCheck,~\cite{claessen_quickcheck_2000}, to verify correctness. In future
work, dependently typed programming can be used to prove correctness.


% \section{Approach}

% We want to model Polynomial → Monoid → Ring → Field → Vector Space in some way.

The approach is to start by implementing basic mathematical constructs such as
Monoids, Groups and Rings and continue to more powerful and complicated
constructs such as Vector spaces. From there we can implement more specific
datatypes for concepts used in FEEC such as Simplices and Barycentric
coordinates. We will continuously test invariants for each construct to make sure
the implementation is correct.

Debugging mathematical errors is hard, we wish to investigate how functional
tools can increase correctness in the implementation.



% Implement a mathematical theory.
% In a conventional implementation it is hard to debug mathematical errors.
% If we instead model the mathematical theory using types and typeclasses we can
% use automated testing and proving.
% This is a case study in such a implementation.
% We want to model Polynomial → Monoid → Ring → Field → Vector Space in some way.
% Or Barycentric Coords → Bernstein Polynomials → Simplices, stuff from the
% actual theory.
% When modeling the actual mathematical terms as polymorphic types over the
% underlying number implementation, we can test using a exact type like
% rationals, but run using a fast type like doubles.

% This is about understanding of the mathematics.

% Is there anything to gain by modeling the structure "below" and not just the
% terms currently of interest?

% Hopefully we can test invariants of the implementation using QuickCheck.

% Elevator pitch: "Debugging mathematics is hard, use functional programming"

% "Implementing a mathematical theory as a DSL"

% "Implementing a mathematical theory from the ground up"

% "Model the actual algebra as types and typeclasses"



\bibliographystyle{plain}

\bibliography{sfeeca}

\end{document}
